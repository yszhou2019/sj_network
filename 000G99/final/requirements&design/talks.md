

# talks



## 1. 数据库的考量



### 不能采用path+name作为file的PK的原因

几种可能的操作

某文件夹下，有很多文件（假设有2万以上的小文件）：
1 删除整个文件夹
2 文件夹重命名
3 文件夹下的某个文件，增加/删除/修改/重命名

case 1，删除整个文件夹

>
>
>数据库 path + name 作为主键
>如果文件item用 path + name 作为主键的话，删除文件夹这个操作，其实也行，对主键进行前缀匹配，然后匹配项进行删除操作
>
>

case 2，文件夹重命名

>
>
>path+name作为主键=>不可取（C->S：需要执行2万个任务，2万个update任务）
>需要把之前的文件夹名称，记录下来，然后更新所有匹配项，如果2万个子文件，那么就需要更新2万项

case 3，某个子文件增删重命名

>
>
>path+name
>记录旧文件名，然后找到匹配项，也行



=>数据库不能采用path+name作为主键





### 数据库可能的想法



|      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |
|      |      |      |      |      |      |
|      |      |      |      |      |      |
|      |      |      |      |      |      |
|      |      |      |      |      |      |



一个folder，有10万个子文件，1对N，folder有PK，子文件有PK
如何设计，文件夹的PK作为子文件的一个字段

>
>
>每个用户，有自己对应的很多文件夹节点，
>
>每个文件夹节点，需要的字段：自己文件夹的编号，自己文件夹的名称，自己文件夹的父节点的编号
>
>每个文件节点，需要的字段：自己的



关于文件夹的考虑

>
>
>不管何种结构，最终是要执行操作的
>
>先考虑常见的，性能可能会有影响的场景
>
>某个dir有2万个子文件：
>1 dir的移动
>2 dir的重命名
>3 dir的删除
>
>1 比如：
>
>|                      | 操作量                                                       |      |
>| -------------------- | ------------------------------------------------------------ | ---- |
>| 整体上移             | O(1)                                                         |      |
>| 整体下移             | O(1)                                                         |      |
>| 移动目录中的一半数据 | 遍历dir表和file表，找到所有引用这个目录的目录/文件，change parent_dir_PK<br />操作成本，dir全表，file全表，然后更改 |      |
>
>2 dir的重命名，O(1)
>
>3 dir的删除，需要**递归dir，把所有子dir全包含了**(不止扫描一遍全表)，还有扫描file表的全表

勾连关系由谁来存储？
由child来存储，还是由parent存储？

如果用child来存储勾连，

如果用parent来存储勾连，

|                    | child存储勾连（下层指向上层）                                | parent存储勾连（上层包含下层）                               | 三层结构 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 整体上移           | 改变cur_dir的parent_PK...                                    | 找到old_parent，找到new_parent，将moved目录节点从old中删除，添加到new中 |          |
| 整体下移           | 改变cur_dir的parent_PK...                                    | ...                                                          |          |
| 移动目录的一半数据 | 找到所有以cur_dir为parent_dir的节点（需要扫描2个表）<br />数据文件**有多少个，就要改动多少项**<br />目录文件，**每个目录都需要完整扫描一遍dir表** | 对于这些移动的数据项，找到原有的old_parent，找到new_parent... |          |
| dir的重命名        | ...                                                          | ...                                                          |          |
| dir的删除          | 需要不断递归dir表，每个子文件夹都需要扫描一遍（需要多次递归） | 数据文件直接减少引用次数，dir需要回表递归                    |          |
| 是否可行           | 不行                                                         |                                                              |          |





## 2. linux client对于本地文件夹的监控

方案1

>inotify
>
>可以为client提供什么功能？
>持续监控本地指定文件夹下的所有操作
>
>下载，`yum install inotify-tools`
>如果仓库没有，下载方式参考下面
>
>```bash
>wget https://download-ib01.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm # step 1
>rpm -Uvh epel-release*rpm # step 2
>dnf install inotify-tools # step 3
>```
>
>
>
>使用，可以采用脚本的方式运行，也可以在cpp中用inotify的API





## 3. 断点续传

下载，临时文件head部分写信息

上传，后续需要多客户端上传同一份文件来加速，断点信息写入服务器数据库中