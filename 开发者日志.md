

客户端在进行deletefile之后，收到所有的deletefileres，再进行getdir和服务器进行比对

否则，服务器的目录还没有同步，就又获取了服务器的目录

导致客户端已经删除的文件，又下载了下来



___





服务器的结构，采用fork子进程+epoll 或者 select





- uploadChunk分裂为两个API

>询问Chunk是否需要上传
>
>以及进行真正的chunk上传
>
>





- 处理服务器对包的接收和发送

>采用buffer？
>
>**可以这么做**，但是考虑到文件的数据有可能掺杂在buffer中，而我之前采用的是splice方案，所以，**暂时搁置**
>
>做出的class在rio.hpp readbuf中，需要把write_res_to_file完成，这个函数细节有点多，所以暂时搁置
>细节包括，比如连续两个uploadChunk的请求+文件...





- 处理客户端并发访问服务器的问题

>解决了什么问题？客户端并发访问服务器，服务器繁忙导致客户端一直等待。
>
>问题根源？之前的服务器，单进程单线程，用多路复用处理并发问题。这种结构，可以处理简单的请求，但是如果文件传输，那么会导致进程繁忙，从而对其他 socket 失去响应。
>
>如何处理？多进程模型。父级 fork，仅仅连接socket；子进程运行 epoll 循环 或者 select 循环，直到 侦测到socket 被关闭，或者主动关闭 socket。
>
>





07-03 12:23

- server接受数据失败之后的问题（server把数据文件当成请求，不断接受，然后丢弃）

>接收到废弃数据，不断丢弃，导致不断触发epoll，接收type的长度大于20，导致了解析json出错，导致宕机
>
>（部分废弃数据）收到一个包，丢弃一个包
>
>方案1，临时方案，把数据写入到文件中（对应的包已经有了，覆盖的是相同数据，没有问题）
>方案2，如果验证不是之后，直接关闭socket，也就是说，非法请求，直接关闭socket（否则还会有错误的数据）
>
>recv buffer之后，接收type的长度大于20，导致了解析json出错，导致宕机
>
>解决方案，只有当type类型合法的时候，才允许parse json，如果不合法，那么直接close_realease()。认为是恶意攻击



07-03 01:31

- splice的时候，如果socket断开（上传 / 下载）都会阻塞在splice函数，导致服务器没有响应

>```
>>>> man splice
>  SPLICE_F_NONBLOCK
>         Do not block on I/O.  This makes the splice pipe  operations  nonblocking,
>         but  splice() may nevertheless block because the file descriptors that are
>         spliced to/from may block (unless they have the O_NONBLOCK flag set).
>```
>
>splice默认是阻塞的，需要设置最后一个参数为`SPLICE_F_NONBLOCK`
>
>splice采用非阻塞的话，还有必要检查socket ready吗？
>
>有必要，如果不检查，那么splice由于非阻塞，会直接返回-1，但是实际上仍然有数据可读
>所以必须要检查socket ready
>
>
>
><img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210703015238.png" alt="image-20210703015238702" style="zoom:80%;" />
>
>



07-03 00:37

- 秒传逻辑纠正

>何时秒传？
>
>用pfile表存储md5对应的物理文件信息，包括{ md5，分块传输进度情况，已上传块数，总块数，是否完整 }只有当服务器的pfile存在对应的md5记录，并且complete的时候，才是秒传
>
>否则，有两种情况
>
>1 pfile存在，但是没有上传完毕，对应情况（服务器中有这个文件，但是没有上传完毕）这个时候仍然需要用户上传
>
>2 pfile不存在，对应情况（服务器根本没有这个文件，需要在pfile中添加记录）那么用户应当上传
>
>
>
>解决的问题？解决了异常情况下的文件上传和下载。
>
>按照旧的判定逻辑，md5文件存在就判断秒传完毕，那么一旦客户端下载没有上传完毕的文件，下载得到的文件就是错误的文件
>
>本次改动，避免了这种没有上传完毕就下载，导致下载到的文件出错的情况

另外一点

获取服务端目录

>获取的是对应的文件已经complete的文件，如果文件尚未上传完毕，那么不应当返回给客户端
>
>





07-02 16:21

- getdir() 获取uid对应的所有文件，包括上传完毕的文件以及没有上传完毕的文件 -> getdir() 在uid对应的所有文件中，只能获取已经上传完毕的文件

>解决了什么问题？同一个用户，两个客户端，客户端A一个上传文件但还没有完成，那么客户端B可能就会getdir()来获取服务器目录，从而客户端B直接下载`尚未上传完毕的文件`，从而导致多机不一致
>
>这样子改动的话，同一个用户，独立用两台机器，两个客户端，会有什么问题？
>
>
>
>这样子改动的话，不同的用户，上传文件的时候，什么情况下才能秒传？已经传输完毕的文件才能秒传？还是说，
>
>是不是说，如果客户端A已经上传完毕了文件之后，其他的客户端上传，才允许秒传？
>
>假设客户端A上传了文件的一部分，之后客户端 A 无法继续上传（暂停上传/手动退出/异常退出/电脑关机/网络异常等等），此时客户端B上传相同文件，那么应该秒传成功吗？秒传成功，意味着客户端可以下载到完整的数据文件，所以说，不能判定为秒传成功。只有当md5匹配，并且文件已经上传完毕，才允许秒传成功。如果对应的实体文件没有上传完毕，那么应当提示客户端B继续上传。
>
>判断秒传逻辑，md5对应的文件存在(old) ->  数据库中可以获取md5的文件信息，并且complete=1(now)
>
>

